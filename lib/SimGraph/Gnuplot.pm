=head1 NAME

SimGraph::Gnuplot - Simulation and Graph-generation utilities - Gnuplot graph generator

=head1 DESCRIPTION

The C<SimGraph::Gnuplot> module provides an object-oriented interface
to create a 2-D or 3-D graph using C<gnuplot>(1).

=head1 SYNOPSIS

  require SimGraph::Gnuplot;
  my $g = SimGraph::Gnuplot->new;
  
  :
  $g->add_data (...);
  :
  
  $g->plot;

=cut

use strict;
package SimGraph::Gnuplot;
use SimGraph::IO qw/xsystem/;

=head1 METHODS

=over 4

=item I<$g> = SimGraph::Gnuplot->new

Creates and returns a new instance of the C<SimGraph::Gnuplot>.

=cut

sub new ($) {
  my $self = bless {data => [], linestyle => [], label => [], pointing_label => []}, shift;
  $self;
} # new

=item [I<$x_axis_type> =] I<$g>->x_axis ([I<$new_x_axis_type>])

Gets or sets the type, i.e. what is plotted, of the x-axis.
It might return C<undef> if the type is not set yet.

=cut

sub x_axis ($;$) {
  my $self = shift;
  $self->{x_axis} = shift if @_;
  return $self->{x_axis};
} # x_axis

=item [I<$y_axis_type> =] I<$g>->y_axis ([I<$new_y_axis_type>])

Gets or sets the type, i.e. what is plotted, of the y-axis.
It might return C<undef> if the type is not set yet.

=cut

sub y_axis ($;$) {
  my $self = shift;
  $self->{y_axis} = shift if @_;
  $self->{y_axis};
} # y_axis

=item [I<$z_axis_type> =] I<$g>->z_axis ([I<$new_z_axis_type>])

Gets or sets the type, i.e. what is plotted, of the z-axis.
It might return C<undef> if the type is not set yet.

=cut

sub z_axis ($;$) {
  my $self = shift;
  $self->{z_axis} = shift if @_;
  $self->{z_axis};
} # z_axis

=item [I<$ant_ttl> =] I<$g>->ant_ttl ([I<$new_ant_ttl>])

Gets or sets the TTL of the ants.  Unless a value is explicitly set,
or set to zero, C<30> is returned.

=cut

sub ant_ttl ($;$) {
  my $self = shift;
  $self->{ant_ttl} = shift if @_;
  return $self->{ant_ttl} || 30;
} # ant_ttl

=item I<$str> = I<$g>->stringify

Returns the string representation of the content of the
input file to the C<gnuplot>(1) command.

=cut

sub stringify ($) {
  my $self = shift;
  my $r = '';
  $r .= $self->stringify_linestyle;
  $r .= $self->stringify_set_terminal;
  $r .= $self->stringify_set_output if $self->written_to_file;
  $r .= $self->stringify_axes;
  $r .= "set nokey\n" unless $self->with_keys;
  $r .= $self->stringify_title;
  $r .= $self->stringify_label;
  $r .= $self->_stringify_set;
  
  $r .= $self->stringify_plot;
  $r .= "pause -1\n" unless $self->written_to_file;
  $r;
} # stringify

=item [I<$terminal> =] I<$g>->terminal ([I<$new_terminal>])

The type of the terminal to which the graph is rendered.

Supported terminal types:

=over 4

=item eps

An EPS (Encapsulated PostScript) file.

=item png

A PNG (Portable Network Graphics) file.

=item x11

An X11 window.

=back

If it is not explicitly specified, then C<png> is returned.

=cut

sub terminal ($;$) {
  my $self = shift;
  $self->{terminal} = shift if @_;
  defined $self->{terminal} ? $self->{terminal} : 'png';
} # terminal

sub stringify_set_terminal ($) {
  my $self = shift;
  my $terminal = $self->terminal;
  'set terminal ' . ({
    x11 => 'x11',
    png => 'png', # 'png color',
    eps => 'postscript eps color',
  }->{$terminal} or die "$0: $terminal: Unsupported terminal type") . "\n";
} # stringify_set_terminal

=item [I<$file_name_stem> = I<$g>->file_name_stem ([I<$new_file_name_stem>])

The main part of the file name of the files possibly generated by C<$g>.
It MAY contain path to the file.  If the file name stem is
not explicitly specified, then C<temp> is returned.

=cut

sub file_name_stem ($;$) {
  my $self = shift;
  $self->{file_name_stem} = shift if @_;
  defined $self->{file_name_stem} ? $self->{file_name_stem} : 'temp';
} # file_name_stem

=item I<$file_name> = I<$g>->file_name

Returns the name of the file to be generated by C<< I<$g>->plot >>.
If the C<< I<$g>->terminal >> is not a terminal that will create
a file, then this method returns a file name that would be returned
if the C<png color> terminal is specified.

=cut

sub file_name ($) {
  my $self = shift;
  my $file_name = $self->file_name_stem;
  $file_name .= ({
    eps => '.eps',
    png => '.png',
  }->{$self->terminal} or '.png');
  return $file_name;
} # file_name

=item I<$written_to_file> = I<$g>->written_to_file

Returns whether the current C<< I<$g>->terminal >> is so defined
that C<< I<$g>->plot >> will write a graph into a file.

=cut

sub written_to_file ($) {
  my $self = shift;
  return not {
    x11 => 1,
  }->{$self->terminal};
} # written_to_file

sub stringify_set_output ($) {
  my $self = shift;
  my $file_name = $self->file_name;
  warn "Output: $file_name\n";
  'set output "' . $file_name . '"' . "\n";
} # stringify_set_output

sub stringify_axes ($) {
  my $self = shift;
  my $r = '';
  for my $axis (qw/x y z/) {
    my $axis_type = $self->{$axis . '_axis'};
    next unless defined $axis_type;
    if ($axis_type eq 'time') {
      $r .= "set ${axis}label 'time [s]'\n";
      my $time_end_s = $self->time_end_s;
      $r .= "set ${axis}range [0:$time_end_s]\n" if $time_end_s > 0;
    } elsif ($axis_type eq 'my-x-axis') {
      $r .= "set ${axis}label 'my x-axis [/s]'\n";
      $r .= "set ${axis}range [0.1:1000]\n";
      $r .= "set logscale ${axis}\n";
    } elsif ($axis_type eq 'real') {
      #$r .= "set ${axis}tics 1\n";
    } else {
      die "$0: $axis = $axis_type: Unsupported axis type";
    }
  }
  $r;
} # stringify_axes

=item [I<$time> =] I<$g>->time_end_s ([I<$new_time>]);

Gets and/or sets the time in seconds at which the simulation ends.
This value is used as the maximum value of the axis of type C<time>.

=cut

sub time_end_s ($;$) {
  my $self = shift;
  $self->{time_end} = shift () * 1000 if @_;
  (defined $self->{time_end} ? $self->{time_end} : 0) / 1000;
} # time_end_s

=item [I<$time> =] I<$g>->time_end_s ([I<$new_time>]);

Gets and/or sets the time in milliseconds at which the simulation ends.
This value is used as the maximum value of the axis of type C<time>.

=cut

sub time_end_ms ($;$) {
  my $self = shift;
  $self->{time_end} = shift if @_;
  (defined $self->{time_end} ? $self->{time_end} : 0);
} # time_end_ms

=item [I<$with_keys> =] I<$g>->with_keys [I<$new_with_keys>];

Gets and/or sets whether the legend should be rendered
in the graph or not.  Unless a value is explicitly set, or if C<undef>
is set, then this method returns true if and only if the I<$g> object
contains more than one data.

=cut

sub with_keys ($;$) {
  my $self = shift;
  $self->{with_keys} = shift if @_;
  (defined $self->{with_keys} ? $self->{with_keys} : @{$self->{data}} > 1);
} # with_keys

=item I<$g>->clear_data;

Removes all data contained by the I<$g> object.

=cut

sub clear_data ($) {
  my $self = shift;
  $self->{data} = [];
} # clear_data

=item I<$g>->add_data (I<options>)

Adds a data to plot.

Options:

=over 4

=item file_name => I<file-name> (Required)

The data file to plot.

=item index => I<integer> (Default: none)

=item title => I<title> (Default: none)

=item using => I<using> (Default: none)

=item with => I<with> (Default: none)

Arguments for C<gnuplot> (1)'s C<plot> or C<splot> command.

=item linestyle => I<line-style> (Default: none)

The linestyle identifier used to render the data.
It MUST be a value returned by C<< I<$g>->add_linestyle >>.

=back

=cut

sub add_data ($%) {
  my $self = shift;
  my %opt = @_;
  push @{$self->{data}}, {%opt};
} # add_data

sub stringify_plot ($) {
  my $self = shift;
  die "$0: No data" unless @{$self->{data}};
  my $r = $self->use_z ? 'splot ' : 'plot ';
  my $ticslevel = $self->ticslevel;
  $r = "set ticslevel $ticslevel\n$r" if defined $ticslevel;
  my @l;
  for my $data (@{$self->{data}}) {
    my $l = q<'> . $data->{file_name} . q<'>;
    $l .= q< index > . $data->{index} if defined $data->{index};
    $l .= ' using ' . $data->{using} if defined $data->{using};
    $l .= q< title '> . $data->{title} . q<'> if defined $data->{title};
    $l .= ' with ' . $data->{with} if defined $data->{with};
    $l .= ' linestyle ' . $data->{linestyle} if defined $data->{linestyle};
    push @l, $l;
  }
  $r .= join ", \\\n\t", @l;
  $r .= "\n";
  $r;
} # stringify_plot

=item I<$linestyle> = I<$p>->add_linestyle (type => I<linetype>, width => I<linewidth>)

Adds a style to plot data.  The method returns a linestyle identifier
that can be specified to the C<linestyle> option to the 
C<< I<$g>->add_data >> method.

=over 4

=item type => I<linetype> (Required)

The number that represents the type of the line.

=item width => I<linewidth) (Required)

The number that represents the width of the line.

=back

=cut

sub add_linestyle ($%) {
  my $self = shift;
  my %opt = @_;
  push @{$self->{linestyle}}, {%opt};
  $#{$self->{linestyle}} + 1;
} # add_linestyle

sub stringify_linestyle ($) {
  my $self = shift;
  my $r = '';
  for my $i (0..$#{$self->{linestyle}}) {
    my $ls = $self->{linestyle}->[$i];
    #$r .= "set linestyle $i linetype $ls->{type} linewidth $ls->{width}\n";
    $r .= "set style line @{[$i+1]} linetype @{[$ls->{type} or 1]} linewidth @{[$ls->{width} or 1]}\n";
  }
  $r;
} # stringify_linestyle

=item I<$title> = I<$g>->title ([I<$new_title>]);

Gets and/or sets the title of the graph.  The value MAY be C<undef>,
which represents the graph has no title.

=cut

sub title ($;$) {
  my $self = shift;
  $self->{title} = shift if @_;
  return $self->{title};
} # title

sub stringify_title ($) {
  my $self = shift;
  my $r = '';
  $r .= "set title '$self->{title}'\n" if defined $self->{title};
  $r;
} # stringify_title

=item I<$g>->add_label (I<options>)

Adds a text label.

Options:

=over 4

=item title => I<title> (Required)

The text to render.

=item x => I<coord> (Default: C<0>)

=item y => I<coord> (Default: C<0>)

The coordinate to which the text label is anchored,
specified in the format that can be interpreted by C<gnuplot> (1).

=back

=cut

sub add_label ($%) {
  my ($self, %opt) = @_;
  push @{$self->{label}}, \%opt;
} # add_label

=item $g->add_pointing_label (...)

@@

=cut

sub add_pointing_label ($%) {
  my ($self, %opt) = @_;
  push @{$self->{pointing_label}}, \%opt;
} # add_pointing_label

=item I<$g>->clear_label

Removes all text labels contained by the I<$g> object.

=cut

sub clear_label ($) {
  my $self = shift;
  $self->{label} = [];
  $self->{pointing_label} = [];
} # clear_label

sub stringify_label ($) {
  my $self = shift;
  my $r = '';
  for my $label (@{$self->{label}}) {
    $r .= q<set label '> . $label->{title} . q<' at > . ($label->{x} or 0) . q<, > . ($label->{y} or 0) . "\n";
  }
  for my $label (@{$self->{pointing_label}}) {
    my $anchor_x = $label->{x2} || 0;
    my $anchor_y = $label->{y2} || 0;
    ## NOTE: Suitable value only for |screen|
    my $text_width = 0.014 * length $label->{title};
    my $padding_horizontal = 0.02;
    $label->{text_anchor} ||= 'left';
    my $text_x = $anchor_x;
    $text_x =~ s/([0-9.]+)/$1 - $text_width/e if $label->{text_anchor} eq 'right';
    my $text_y = $anchor_y;
    my $joint_x = $anchor_x;
    my $joint_y = $anchor_y;
    $joint_x =~ s/([0-9.]+)/$1 + $padding_horizontal * ($label->{text_anchor} eq 'right' ? 0 : -1)/e;
    $joint_y =~ s/([0-9.]+)/$1 - $padding_horizontal/e;
    my $another_x = $joint_x;
    my $another_y = $joint_y;
    $another_x =~ s/([0-9.]+)/$1 + ($text_width + $padding_horizontal)
        * ($label->{text_anchor} eq 'right' ? -1 : 1)/e;
    $r .= q<set label '> . $label->{title} . q<' at > .
        join (', ', $text_x, $text_y, ($label->{z2} or 0)) . "\n";
    my $option = '';
    if ($label->{linestyle}) {
      $option .= ' linestyle ' . $label->{linestyle};
    }
    $r .= q<set arrow nohead> . $option . q< from > .
        join (', ', ($label->{x1} or 0), ($label->{y1} or 0), ($label->{z1} or 0)) . q< to > .
        join (', ', $joint_x, $joint_y, ($label->{z2} or 0)) . "\n";
    $r .= q<set arrow nohead> . $option . q< from > .
        join (', ', $joint_x, $joint_y, ($label->{z2} or 0)) . q< to > .
        join (', ', $another_x, $another_y, ($label->{z2} or 0)) . "\n";
  }
  return $r;
} # stringify_label

=item I<$g>->plot

Creates a C<gnuplot> (1) command file and then
run C<gnuplot> (1) to generate the graph.

=cut

sub plot ($) {
  my $self = shift;
  my $file_name_stem = $self->file_name_stem;
  
  my $plot_file_name = "$file_name_stem.plt";
  open my $plot_file, '>', $plot_file_name or die "$0: $plot_file_name: $!";
  print $plot_file $self->stringify;
  close $plot_file;
  
  xsystem 'gnuplot', $plot_file_name;
} # plot

=item [I<$use_z> =] I<$g>->use_z ([I<$new_use_z>]);

Gets and/or sets whether the z-axis is rendered or not,
in other word the graph is rendered as in 3-D or not.

=cut

sub use_z ($;$) {
  my $self = shift;
  $self->{use_z} = shift if @_;
  return $self->{use_z};
} # use_z

=item [I<$ticslevel> =] I<$g>->ticslevel ([I<$new_ticslevel>])

Gets and/or sets the value of the C<ticslevel>.  It MAY be C<undef>
if no C<ticslevel> should be specified explicitly.

=cut

sub ticslevel ($;$) {
  my $self = shift;
  $self->{ticslevel} = shift if @_;
  return $self->{ticslevel};
} # ticslevel

=item I<$g>->add_set (I<SET-ARGUMENTS>)

Adds a list of C<gnuplot> (1) C<set> arguments.

=cut

sub add_set ($@) {
  my ($self, @opt) = @_;
  push @{$self->{set}}, \@opt;
} # add_set

sub _stringify_set ($) {
  my ($self) = @_;
  my $r = '';
  for (@{$self->{set}}) {
    $r .= join ' ', 'set', @$_;
    $r .= "\n";
  }
  return $r;
} # _stringify_set

1;

__END__

=back

=head1 EXAMPLE

  require SimGraph::Gnuplot;
  my $plot = SimGraph::Gnuplot->new;
  $plot->terminal ($self->{param}->output_format);
  $plot->x_axis ('time');
  $plot->time_end_ms ($self->{param}->simulation_time_end);
  $plot->y_axis ('my-y-axis-type');
  $plot->file_name_stem ($file_name_stem);
  my $line1 = $plot->add_linestyle (type => 1, width => 3);
  my $line2 = $plot->add_linestyle (type => 2, width => 3);
  $plot->add_data (file_name => $data_file_name, index => 0,
      with => 'steps', using => q[($1 / 1000):(1000 / $2)],
      linestyle => $line1, title => 'value 1');
  $plot->add_data (file_name => $data_file_name, index => 1,
      with => 'steps', using => q[($1 / 1000):(1000 / $2)],
      linestyle => $line2, title => 'value 2');
  $plot->plot;

=head1 SEE ALSO

The L<SimGraph::Canvas::Gnuplot> module provides more abstract
interface, which would be more useful for most cases than using this
module directly.

=head1 AUTHOR

Wakaba <w@suika.fam.cx>.

=head1 LICENSE

Copyright 2006-2007 Wakaba <w@suika.fam.cx>.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
